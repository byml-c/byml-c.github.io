import{_ as t}from"./Pasted image 20240521174612-CXktuQ8x.js";import{_ as a,r as e,o as d,c as s,e as n,d as l}from"./app-cWQpaTe1.js";const r="/assets/Pasted%20image%2020240521162113-CRtaUMj4.png",c="/assets/Pasted%20image%2020240521165318-D9at4vQT.png",h="/assets/Pasted%20image%2020240521174426-CPnprpVW.png",o="/assets/Pasted%20image%2020240521175633-BeO_0MQN.png",u="/assets/Pasted%20image%2020240524161831-CdHaWfGa.png",p={},v=l('<h2 id="第一讲-概述与指令系统设计" tabindex="-1"><a class="header-anchor" href="#第一讲-概述与指令系统设计"><span>第一讲 概述与指令系统设计</span></a></h2><h3 id="指令系统概述" tabindex="-1"><a class="header-anchor" href="#指令系统概述"><span>指令系统概述</span></a></h3><p>指令系统处在软/硬件交界面，同时被硬件设计者和系统程序员看到</p><ul><li>硬件设计者角度：指令系统为 CPU 提供功能需求，要求易于硬件设计</li><li>系统程序员角度：通过指令系统来使用硬件，要求易于编写编译器 指令系统设计的好坏还决定了：计算机的性能和成本 冯·诺依曼结构机器对指令的规定：</li><li>用二进制表示，和数据一起存放在主存中</li><li>由两部分组成：操作码和操作数（或其地址码）</li></ul><h3 id="指令系统设计" tabindex="-1"><a class="header-anchor" href="#指令系统设计"><span>指令系统设计</span></a></h3><h4 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h4>',6),g=l('<ul><li>Instruction Fetch：从存储器读取指令 <ul><li>指令地址、指令长度（定长/边长）</li></ul></li><li>Instruction Decode：对指令译码，以确定将要做什么操作 <ul><li>指令格式、操作码编码、操作数类型</li></ul></li><li>Operand Fetch：计算操作数地址并取操作数 <ul><li>地址码、寻址方式、操作数格式和存放</li></ul></li><li>Execute：进行相应计算，并得到标志位 <ul><li>操作类型、标志或条件码</li></ul></li><li>Result Store：将计算结果保存到目的地 <ul><li>结果数据位置（目的操作数）</li></ul></li><li>Next Instruction：计算下条指令地址（通常和取指令同时进行） <ul><li>下条指令地址（顺序/转移） 指令执行的每一步都可能发生异常或中断，因此，指令集系统架构（ISA）还需要考虑异常和中断机制。 操作功能：用操作码表示，指定操作类型 源操作数参照：一个或多个源操作数所在的地址</li></ul></li></ul><h5 id="指令" tabindex="-1"><a class="header-anchor" href="#指令"><span>指令</span></a></h5><ul><li>零地址指令 <ol><li>无需操作数，如空操作、停机等</li><li>所需操作数为默认的，如堆栈、累加器等</li></ol></li><li>一地址指令 <ol><li>单目运算：如取反、取负等</li><li>双目运算：另一操作数为默认的，如累加器等</li></ol></li><li>二地址指令（最常用）</li><li>三地址指令</li><li>多地址指令</li></ul><h5 id="指令格式的设计" tabindex="-1"><a class="header-anchor" href="#指令格式的设计"><span>指令格式的设计</span></a></h5><ul><li>应尽量短</li><li>要有足够的操作码位数</li><li>指令编码必须有唯一的解释，否则是不合法的指令</li><li>指令字长应是字节的整数倍</li><li>合理地选择地址字段的个数</li><li>指令尽量规整</li></ul><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p>一般通过对操作码进行不同的编码来定义不同的含义，操作码相同时，再由功能码定义不同的含义。</p></div></div><ul><li>操作码的全部组成：操作码个数、种类、复杂度 LD/ST/INC/BRN 四种指令已经足够编制任何可计算程序，但程序会很长</li><li>数据类型：对哪几种数据类型完成操作</li><li>指令格式：指令长度、地址码个数、各字段长度</li><li>通用寄存器：个数、功能、长度</li><li>寻址方式：操作数地址的指定方式</li><li>下条指令的地址如何确定：顺序，PC+1，条件转移，无条件转移……</li><li>异常和中断机制，包括存储保护方式等</li></ul><h5 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h5><ul><li>地址（指针）：被看成无符号整数，用来参加运算以确定主（虚）存地址</li><li>数值数据 <ul><li>定点数（整数）：一般用二进制补码表示</li><li>浮点数（实数）：大多机器采用 IEEE754 标准</li><li>十进制数：用 NBCD 码表示，压缩/非压缩（汇编程序设计时使用）</li></ul></li><li>位、位串、字符和字符串：用来表示文本、声音和图像等 <ul><li>4bits = nibble, 8bits = byte</li><li>16bits = half-word, 32bits = word</li></ul></li><li>逻辑（布尔）数据：按位操作（0-假/1-真）</li></ul><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content"><p>操作数存放在寄存器或内存单元中，也可以以立即数的形式存在</p></div></div><h4 id="操作数及其寻址方式" tabindex="-1"><a class="header-anchor" href="#操作数及其寻址方式"><span>操作数及其寻址方式</span></a></h4><h5 id="addressing-modes-寻址方式" tabindex="-1"><a class="header-anchor" href="#addressing-modes-寻址方式"><span>Addressing Modes（寻址方式）</span></a></h5><ul><li>寻址方式：指令或操作数地址的指定方式</li><li>地址码编码由操作数的寻址方式决定</li><li>地址码编码原则 <ul><li>指令地址码尽量短→目标代码短，省空间</li><li>操作数存放位置灵活，空间应尽量大→利于编译器优化产生高效代码</li><li>地址计算过程尽量简单→指令执行快（可变长地址寻址需要计算）</li></ul></li><li>寻找方式的确定 <ol><li>没有专门的寻址方式位（由操作码确定寻址方式）</li><li>有专门的寻址方式位</li></ol></li><li>有效地址：操作数所在存储单元的地址（逻辑或物理），可通过指令的寻址方式和地址码计算得到</li><li>基本寻址方式：立即、直接、间接 假设：A = 字段值，R = 寄存器编号，EA = 有效地址，(X) = X 中的内容</li></ul><table><thead><tr><th>方式</th><th>算法</th><th>优点</th><th>缺点</th><th>操作数存储位置</th></tr></thead><tbody><tr><td>立即数</td><td>操作数 = A</td><td>指令执行速度快</td><td>操作数幅值有限</td><td>指令寄存器</td></tr><tr><td>直接</td><td>EA = A</td><td>有效地址计算简单</td><td>地址范围有限</td><td>存储器</td></tr><tr><td>间接</td><td>EA = (A)</td><td>有效地址范围大</td><td>多次存储器访问</td><td>存储器</td></tr><tr><td>寄存器（直接）</td><td>操作数 = (R)</td><td>指令执行快，指令短</td><td>地址范围有限</td><td>寄存器</td></tr><tr><td>寄存器间接</td><td>EA = (R)</td><td>地址范围大</td><td>额外存储器访问</td><td>存储器</td></tr><tr><td>偏移</td><td>EA = A + (R)</td><td>灵活</td><td>复杂</td><td>存储器</td></tr><tr><td>栈</td><td>EA = 栈顶</td><td>指令短</td><td>应用有限</td><td>存储器</td></tr></tbody></table><h5 id="偏移寻址" tabindex="-1"><a class="header-anchor" href="#偏移寻址"><span>偏移寻址</span></a></h5><p>指令组成：OP R A 指令中给出的地址码 A 成为形式地址。EA=A+(R)，R 可以明显给出，也可以隐含给出。R 可以为 PC、基址寄存器 B、变址寄存器 I</p><ul><li>相对寻址：EA=A+(PC)，相对于当前指令所处位移量为 A 的单元 <ul><li>实现公共子程序、动态链接库（类似规定某条指令的数据永远来自其的下面几行，然后此指令在代码中多处出现）</li></ul></li><li>基址寻址：EA=A+(B)，相对基址 B 所处位移量为 A 的单元 <ul><li>多段程序转移（静态转移，将多段程序合在一起）</li></ul></li><li>变址寻址：EA=A+(I)，相对于首地址 A 所处位移量为 I 的单元 <ul><li>实现数组（每次会自动加/减数组元素的长度 x，即 I=(I)+x）</li></ul></li></ul><h4 id="操作类型和操作码编码" tabindex="-1"><a class="header-anchor" href="#操作类型和操作码编码"><span>操作类型和操作码编码</span></a></h4><h5 id="操作类型" tabindex="-1"><a class="header-anchor" href="#操作类型"><span>操作类型</span></a></h5><ul><li>算术逻辑运算指令 <ul><li>加减乘除、比较、与或非、取反、取负、异或等</li><li>算术运算包含整数和浮点数操作</li></ul></li><li>移位指令 <ul><li>算术移位、逻辑移位、循环移位、半字交换</li></ul></li><li>数据传送指令 <ul><li>寄存器间、内存-寄存器、内存内换</li></ul></li><li>顺序控制指令 <ul><li>条件转移、无条件转移</li><li>调用、返回</li></ul></li><li>系统控制指令 <ul><li>停机、开中断、关中断、系统模式切换等</li></ul></li><li>输入/输出指令</li></ul><h5 id="instruction-format-指令格式" tabindex="-1"><a class="header-anchor" href="#instruction-format-指令格式"><span>Instruction Format（指令格式）</span></a></h5><ul><li>Fixed Length Opcodes（定长操作码法）</li><li>Expanding Opcodes（扩展操作码编法） 指令长度：</li><li>代码长度更重要时：采用变长指令字、变长操作码</li><li>性能更重要时：采用定长指令字、定长操作码 变长更紧凑，定长方便快速访问和译码。操作码长度和指令字长度没有绝对的关系。</li></ul><h5 id="定长操作码编码" tabindex="-1"><a class="header-anchor" href="#定长操作码编码"><span>定长操作码编码</span></a></h5><ul><li>基本思想：指令的操作码部分采用固定长度的编码。</li><li>特点：译码方便，但有信息冗余</li></ul><h5 id="扩展-变长-操作码编码" tabindex="-1"><a class="header-anchor" href="#扩展-变长-操作码编码"><span>扩展（变长）操作码编码</span></a></h5><ul><li>基本思想: 将操作码的编码长度分成几种固定长的格式。被大多指令集采用。</li><li>种类：等长扩展法：4-8-12；3-6-9；……/不等长扩展法</li></ul><h4 id="标志信息的生成与使用" tabindex="-1"><a class="header-anchor" href="#标志信息的生成与使用"><span>标志信息的生成与使用</span></a></h4><h5 id="条件测试方式" tabindex="-1"><a class="header-anchor" href="#条件测试方式"><span>条件测试方式</span></a></h5><p>条件转移指令通常根据 Condition Code 转移，通过执行算数指令或显示地由比较和测试指令来设置 CC 常用的标志（条件码）有四种：</p><ul><li>SF：negative</li><li>OF：overflow</li><li>CF：进位/借位</li><li>ZF：zero 标志可存于 FLAGs（称为标志寄存器/条件码寄存器/状态寄存器/程序状态字寄存器），也可由指定的通用寄存器来存放状态位</li></ul><h5 id="条件转移指令" tabindex="-1"><a class="header-anchor" href="#条件转移指令"><span>条件转移指令</span></a></h5><ul><li>根据单个标志的值转移</li><li>按无符号整数比较转移</li><li>按带符号整数比较转移</li></ul><div class="callout" data-callout="tip"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-flame"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"></path></svg></div><div class="callout-title-inner">转移指令并不是必须的</div></div><div class="callout-content"><p>知道了 SF、OF、CF、ZF 即可判断并转移，其他判断则可以在程序设计阶段实现</p></div></div><h3 id="指令设计风格" tabindex="-1"><a class="header-anchor" href="#指令设计风格"><span>指令设计风格</span></a></h3><h4 id="按照数据存储位置分类" tabindex="-1"><a class="header-anchor" href="#按照数据存储位置分类"><span>按照数据存储位置分类</span></a></h4><h5 id="累加器型-accumulator" tabindex="-1"><a class="header-anchor" href="#累加器型-accumulator"><span>累加器型 (Accumulator)</span></a></h5><p>特点：其中一个操作数和目的操作数总在累加器中</p><ul><li>相当于 ALU 的其中一端始终是累加器 ACC，结果也存储在 ACC 中。 电路更加简单，但效率更低。</li></ul><h5 id="栈型-stack" tabindex="-1"><a class="header-anchor" href="#栈型-stack"><span>栈型 (Stack)</span></a></h5><p>特点：总是将栈顶的两个操作数进行运算，指令无需指定操作数地址</p><h5 id="通用寄存器型-general-purpose-register" tabindex="-1"><a class="header-anchor" href="#通用寄存器型-general-purpose-register"><span>通用寄存器型 (General Purpose Register)</span></a></h5><p>特点：操作数可以是寄存器或存储器数据（即 A、B 和 C 可以是寄存器或存储单元）</p><h5 id="装入-存储型-load-store" tabindex="-1"><a class="header-anchor" href="#装入-存储型-load-store"><span>装入/存储型 (Load/Store)</span></a></h5><p>特点：运算操作只能是寄存器数据，只有 load/store 指令能访问存储器 访问寄存器的速度比访问主存快，可以加快计算速度。</p><h5 id="指令风格比较" tabindex="-1"><a class="header-anchor" href="#指令风格比较"><span>指令风格比较</span></a></h5><ul><li>指令字长</li><li>所需指令数量</li><li>指令执行周期</li></ul><table><thead><tr><th></th><th>栈型</th><th>累加器型</th><th>寄存器型<br>（寄存器存储器通用型）</th><th>寄存器型<br>（装入存储型）</th></tr></thead><tbody><tr><td>指令字长</td><td>短</td><td>短</td><td>长</td><td>长</td></tr><tr><td>所需指令数量</td><td>多</td><td>较少</td><td>较少</td><td>多</td></tr><tr><td>指令执行周期</td><td></td><td></td><td></td><td></td></tr></tbody></table><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">说明</div></div><div class="callout-content"><p></p><ul><li>累加器型所需指令数量较少，但因为所有运算都要使用累加器，表达式比较复杂时，会出现多次移入/移出累加器的指令，从而使累加器型所需指令数量迅速增加</li></ul></div></div><p>寄存器型占据主导地位，优势：</p><ul><li>寄存器速度快，使用大量通用寄存器可减少访存操作</li><li>表达式编译时与顺序无关（相对于 Stack 型）</li></ul><figure><img src="'+r+'" alt="" title="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="按照指令设计的复杂度分类" tabindex="-1"><a class="header-anchor" href="#按照指令设计的复杂度分类"><span>按照指令设计的复杂度分类</span></a></h4><p>复杂指令集计算机（CISC：Complex Instruction Set Computer） 精简指令集计算机（RISC：Reduced Instruction Set Computer）</p><h5 id="cisc-的特点" tabindex="-1"><a class="header-anchor" href="#cisc-的特点"><span>CISC 的特点</span></a></h5><ul><li>指令系统复杂：变长操作码、变长指令字、指令多、寻址方式多、指令格式多</li><li>指令周期长：绝大多数指令需要多个时钟周期才能完成</li><li>各种指令都能访问存储器：除了专门的存储器读写指令外，运算指令也能访问存储器</li><li>采用微程序控制</li><li>有专用寄存器</li><li>难以进行编译优化来生成高效目标代码</li></ul><h5 id="cisc-的缺陷" tabindex="-1"><a class="header-anchor" href="#cisc-的缺陷"><span>CISC 的缺陷</span></a></h5><ul><li>研制周期变长、难以保证设计正确性、难以调试和维护、降低系统性能</li><li>指令出现的频率悬殊很大，常用的简单指令在程序指令中占大多数</li></ul><h5 id="risc-的特点" tabindex="-1"><a class="header-anchor" href="#risc-的特点"><span>RISC 的特点</span></a></h5><ul><li>简化的指令系统：指令少、寻址方式少、指令格式少、指令长度一致</li><li>以 RR 的方式工作：除 Load/Store 指令可访问存储器外，其余指令都只访问寄存器</li><li>指令周期短：以流水线方式工作，除了 Load/Store 指令外，其他指令都需要一个或者不到一个时钟周期即可完成</li><li>采用大量通用寄存器，以减少访存次数</li><li>采用组合逻辑电路控制，不用或少用微程序控制</li><li>采用优化的编译系统，力求有效地支持高级语言程序</li></ul><h3 id="异常和中断处理机制" tabindex="-1"><a class="header-anchor" href="#异常和中断处理机制"><span>异常和中断处理机制</span></a></h3><ul><li>程序执行过程中，CPU 会遇到一些特殊情况，使正在执行的程序被“中断” <ul><li>CPU 终止原来正在执行的程序，转到处理异常情况或特殊事件的程序去执行，结束后再回到原来终止的程序处（断点）继续执行</li></ul></li><li>程序执行被“中断”的事件有两类 <ul><li>内部“异常”：在 CPU 内部发生的意外事件或特殊事件 <ul><li>硬故障中断：如电源掉电、硬件线路故障等</li><li>程序性中断：Exception 事件，如溢出、缺页、越界、越权、越级、非法指令、除数为 0、堆/栈溢出、访问超时、断点设置、单步、系统调用等。</li></ul></li><li>外部“中断”：在 CPU 外部发生的特殊事件，通过“中断请求”信号向 CPU 请求处理。如时钟、控制台、打印机缺纸、外设准备好、采样计时到、DMA 传输结束等。</li></ul></li><li>发生异常（Exception）和中断（Interrupt）事件后，系统将进入 OS 内核态对相应事件进行处理，即改变处理器状态（用户态→内核态）</li></ul><figure><img src="'+c+'" alt="" title="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="第二讲-指令系统实例-risc-v-架构" tabindex="-1"><a class="header-anchor" href="#第二讲-指令系统实例-risc-v-架构"><span>第二讲 指令系统实例：RISC-V 架构</span></a></h2><h3 id="risc-v-指令系统概述" tabindex="-1"><a class="header-anchor" href="#risc-v-指令系统概述"><span>RISC-V 指令系统概述</span></a></h3><ul><li>设计目标 <ul><li>广泛的适应性：从最袖珍的嵌入式微控制器，到最快的高性能计算机</li><li>支持各种异构处理架构，成为定制加速器的基础</li><li>稳定的基础指令架构，并能灵活扩展，且扩展时不影响基础部分</li></ul></li><li>开源理念和实际原则 <ul><li>指令集完全公开，且无需为指令集付费</li><li>采用模块化设计，既保持基础指令集的稳定，也保证扩展指令集的灵活配置</li><li>特点：具有模块化结构、稳定性和扩展性好，在简洁性、实现成本、功耗、性能和程序代码量等方面具有显著优势</li></ul></li><li>模块化结构 <ul><li>核心（RV32I） + 标准扩展集（RV32M、RV32F、RV32D、RV32A） = RV32G</li><li>32 位架构 RV32G = RV32IMAFD，其压缩指令集为 RV32C（指令长度为 16 位）</li><li>64 位架构 RV64G = RV64IMAFD，其压缩指令集为 RV64C（指令长度为 16 位）</li><li>向量计算 RV32V 和 RV64V；嵌入式 RV32E（RV32I 的自己，16 个通用寄存器）</li></ul></li></ul><h3 id="risc-v-指令参考卡和指令格式" tabindex="-1"><a class="header-anchor" href="#risc-v-指令参考卡和指令格式"><span>RISC-V 指令参考卡和指令格式</span></a></h3><h4 id="指令卡" tabindex="-1"><a class="header-anchor" href="#指令卡"><span>指令卡</span></a></h4><ul><li>核心指令集：基础整数指令集 RV32I 和 RV64I</li><li>特权指令：陷阱指令对应的返回指令、wfi等待中断指令、sfence.vma 虚拟存储器的同步操作</li><li>伪指令（一共有 60 个）： <ul><li>如 MoVe rd, rs 指令实际执行了 ADDI rd, rs, 0 指令</li></ul></li><li>压缩指令集：RV32C 和 RV64C <ul><li>压缩指令的底层实现是通过电路转化为标准指令，然后用标准指令的电路进行实现</li></ul></li><li>扩展指令集： <ul><li>乘除运算指令集 RVM、原子操作指令 RVA、浮点运算指令集 RVF 和 RVD、向量操作指令集 RVV</li></ul></li><li>通用寄存器的调用约定： <ul><li>32 个定点通用寄存器 x0~x31；</li><li>32 个浮点寄存器 f0~f31；</li><li>通用寄存器 x0 中恒 0 ；x1 中返回地址；x2、x3 和 x4 分别为栈指针、全局指针和线程指针</li></ul></li></ul><figure><img src="'+h+'" alt="" title="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="指令格式" tabindex="-1"><a class="header-anchor" href="#指令格式"><span>指令格式</span></a></h4><p>RISC-V 采用定长指令，共有6种指令格式：</p><ul><li>R-型为寄存器操作数指令</li><li>I-型为短立即数或装入（Load）指令</li><li>S-型为存储（Store）指令</li><li>B-型为条件跳转指令</li><li>U-型为长立即数操作指令</li><li>J-型为无条件跳转指令 图注：</li><li>opcode：操作码字段</li><li>rd、rs1和rs2：通用寄存器编号</li><li>imm：立即数，其位数在括号[ ]中表示</li><li>funct3和funct7：分别表示 3 位功能码和 7 位功能码，和 opcode 字段一起定义指令的操作功能</li></ul><figure><img src="'+t+'" alt="" title="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="_16-位-risc-v-压缩指令格式" tabindex="-1"><a class="header-anchor" href="#_16-位-risc-v-压缩指令格式"><span>16 位 RISC-V 压缩指令格式</span></a></h6><figure><img src="'+o+'" alt="" title="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每条 16 位指令都有<strong>功能完全相同</strong>的 32 位指令，在执行时由硬件先转换为 32 位指令再执行。目的是：缩短程序代码量，用少量时间换空间。</p><h3 id="risc-v-基础整数指令集" tabindex="-1"><a class="header-anchor" href="#risc-v-基础整数指令集"><span>RISC-V 基础整数指令集</span></a></h3><ul><li>整数运算类指令 <ul><li>移位</li><li>算术运算</li><li>逻辑运算</li><li>比较</li></ul></li><li>控制转移类指令 <ul><li>分支</li><li>跳转链接</li></ul></li><li>系统控制类指令 <ul><li>同步</li><li>环境</li><li>控制状态寄存器</li></ul></li><li>存储访问类指令 <ul><li>取数</li><li>存数</li></ul></li></ul><figure><img src="'+u+'" alt="" title="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">符号扩展</div></div><div class="callout-content"><p></p><ul><li>若为正数，则零扩展和符号扩展是一样的</li><li>若为负数，则 SEXT[1101] = 1111 1101</li></ul><p>统一起来，就是将最高位进行扩展</p></div></div><h3 id="risc-v-可选的扩展指令集" tabindex="-1"><a class="header-anchor" href="#risc-v-可选的扩展指令集"><span>RISC-V 可选的扩展指令集</span></a></h3><ul><li>标准扩展指令集 <ul><li>RV32I基础指令集之上，可标准扩展RV32M、RV32F/D、RV32A，以形成32位架构合集RV32IMAFD，也称为RV32G</li><li>RV32G基础上，对每个指令集进行调整和添加，可形成64位架构RV64G，原先在RV32G中处理的数据将调整为64位。但为了支持32位数据操作，每个64位架构指令集中都会添加少量32位数据处理指令。</li></ul></li><li>RISC-V扩展集包括 <ul><li>针对64位架构需要，在47条RV32I指令基础上，增加12条整数指令（+RV64I），包括6条32位移位指令、3条32位加减运算指令、两条64位装入（Load）指令和1条64位存储（Store）指令，故RV64I共59条指令。</li><li>针对乘除运算需要，提供了32位架构乘除运算指令集RV32M中的8条指令，并在此基础上增加了4条RV64M专用指令（+RV64M）</li><li>针对浮点数运算的需要，提供了32位架构的单精度浮点处理指令集RV32F和双精度浮点处理指令集 RV32D，并在此基础上分别增加了RV64F和RV64D专用指令集（+RV64F）和（+RV64D）。</li><li>针对事务处理和操作原子性的需要，提供了32位架构原子操作指令集RV32A以及RV64A专用指令集 （+RV64A）。</li><li>向量处理指令集RVV、未来可选扩展指令集RVB、RVE、RVH、……</li></ul></li></ul>',82);function f(R,A){const i=e("Mermaid");return d(),s("div",null,[v,n(i,{id:"mermaid-37",code:"eJxLy8kvT85ILCpRCHHhcoz2zCsuKSpNLsnMz1NwSy1JzojlckIRdElNzk9JjeVyjvYvSC1KzEuBKXOJdq1ITS4tAcq5RgelFpfmlCgEl+QXAflu0X6pFSUKSMbEcnE5Kujq2ik4gUlnMOkCJl3BpBuYdOQCAFLwMg0="}),g])}const C=a(p,[["render",f],["__file","第 7 章 指令系统.html.vue"]]),V=JSON.parse('{"path":"/blogs/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E7%AC%AC%207%20%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html","title":"第 7 章 指令系统","lang":"zh-CN","frontmatter":{"date":"2024-06-26","categories":["数字系统设计基础"],"prev":{"text":"第 6 章 运算方法和运算部件","link":"/blogs/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E7%AC%AC%206%20%E7%AB%A0%20%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6.html"},"next":{"text":"第 8 章 中央处理器","link":"/blogs/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E7%AC%AC%208%20%E7%AB%A0%20%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8.html"}},"headers":[{"level":2,"title":"第一讲 概述与指令系统设计","slug":"第一讲-概述与指令系统设计","link":"#第一讲-概述与指令系统设计","children":[{"level":3,"title":"指令系统概述","slug":"指令系统概述","link":"#指令系统概述","children":[]},{"level":3,"title":"指令系统设计","slug":"指令系统设计","link":"#指令系统设计","children":[]},{"level":3,"title":"指令设计风格","slug":"指令设计风格","link":"#指令设计风格","children":[]},{"level":3,"title":"异常和中断处理机制","slug":"异常和中断处理机制","link":"#异常和中断处理机制","children":[]}]},{"level":2,"title":"第二讲 指令系统实例：RISC-V 架构","slug":"第二讲-指令系统实例-risc-v-架构","link":"#第二讲-指令系统实例-risc-v-架构","children":[{"level":3,"title":"RISC-V 指令系统概述","slug":"risc-v-指令系统概述","link":"#risc-v-指令系统概述","children":[]},{"level":3,"title":"RISC-V 指令参考卡和指令格式","slug":"risc-v-指令参考卡和指令格式","link":"#risc-v-指令参考卡和指令格式","children":[]},{"level":3,"title":"RISC-V 基础整数指令集","slug":"risc-v-基础整数指令集","link":"#risc-v-基础整数指令集","children":[]},{"level":3,"title":"RISC-V 可选的扩展指令集","slug":"risc-v-可选的扩展指令集","link":"#risc-v-可选的扩展指令集","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"filePathRelative":"blogs/数字系统设计基础/第 7 章 指令系统.md"}');export{C as comp,V as data};
