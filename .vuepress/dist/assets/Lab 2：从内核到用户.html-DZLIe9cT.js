import{_ as i,r as o,o as c,c as d,e as t,d as e}from"./app-cWQpaTe1.js";const a={},n=e('<h2 id="lab-2-从内核到用户" tabindex="-1"><a class="header-anchor" href="#lab-2-从内核到用户"><span>Lab 2：从内核到用户</span></a></h2><h3 id="系统接手" tabindex="-1"><a class="header-anchor" href="#系统接手"><span>系统接手</span></a></h3><p>当 Bootloader 将操作系统的代码加载到内存以后，就将系统运行的接力棒交到了操作系统手中。操作系统内核会进行一系列初始化，然后开始执行各种用户程序。初始化的流程包括：</p><ul><li>初始化中断向量表（DIT）：接手各类中断事件的处理</li><li>初始化外部中断控制器（8259A）：设置外部中断的开关和中断号</li><li>初始化全局描述符表（GDT）：调整段选择子，写入任务状态段（TSS）和用户相关段的段选择子，并同时设定任务段寄存器（TR）</li><li>初始化设备和驱动：初始化显示设备、键盘驱动等 然后，操作系统内核就可以加载用户程序，并通过从内核态退回用户态的 <code>iret</code> 指令跳转到用户程序的入口。 上述操作服务于两条清晰而紧密相连的主线，即：</li></ul><ol><li>特权级跳转：内核态和用户态之间的跳转</li><li>中断：硬件、内核和用户程序之间的通信</li></ol><h3 id="特权级跳转" tabindex="-1"><a class="header-anchor" href="#特权级跳转"><span>特权级跳转</span></a></h3><p>󱜸 特权级跳转是如何发生的？</p><ul><li>从用户态到内核态的跳转，通过（主动）系统调用和（被动）外部硬件（例如计时器）两类中断。</li><li>从内核态跳转至用户态，是通过 <code>iret</code> 指令。</li></ul><p>󱜸 如何跳转到正确的位置？ 从低特权级到高特权级：</p><ul><li>i386 规定了存储任务状态信息的数据结构（任务状态段 TSS），可使用任务状态段寄存器 TR 来指定其地址。TSS 只用于低特权级向高特权级的跳转，特权级跳转时，CPU 会自动处理 TSS。</li><li>在 TSS 中，存储了一些寄存器（用于硬件上下文切换，在现代系统中使用的较少），还有三个堆栈，每个里面有 <code>SS</code> 和 <code>ESP</code> 两个寄存器，分别存储对应特权级的栈段选择子和栈指针，用以定位。</li><li>进入高特权级后，低特权级的内容会被压入高特权级的栈空间。 从高特权级到低特权级：</li><li>从栈空间中恢复低特权级的栈指针。</li><li>使用 <code>iret</code> 指令，由 CPU 加载 TSS 中的数据进行跳转。</li></ul><div class="callout" data-callout="example"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-list"><line x1="8" x2="21" y1="6" y2="6"></line><line x1="8" x2="21" y1="12" y2="12"></line><line x1="8" x2="21" y1="18" y2="18"></line><line x1="3" x2="3.01" y1="6" y2="6"></line><line x1="3" x2="3.01" y1="12" y2="12"></line><line x1="3" x2="3.01" y1="18" y2="18"></line></svg></div><div class="callout-title-inner">以某次中断为例（ring3 → ring0 → ring3）</div></div><div class="callout-content"><p></p><ol><li>位于 ring3 的用户程序发起系统调用中断 <code>int 0x80</code>，中断参数存储于寄存器中</li><li>CPU 将有关的寄存器写入 TSS 的表区，并从 TSS 栈区取出 <code>SS0</code> 和 <code>ESP0</code> 赋值给对应寄存器</li><li>赋值完成后，在新的堆栈将表区的 EFLAGS、CS、EIP 压入栈（即 ring3 的这几个寄存器的值会存放于 ring0 堆栈栈顶）</li><li>根据 IDT，跳转执行中断处理函数，直到遇到 <code>iret</code> 指令</li><li>从 ring0 堆栈栈顶取出寄存器值并赋值，跳转回 ring3 继续执行用户程序</li></ol></div></div><div class="callout" data-callout="note"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">TSS 的堆栈</div></div><div class="callout-content"><p>TSS 的堆栈是静态的，即 <code>SS0/1/2</code> 和 <code>ESP0/1/2</code> 是固定不变的，也就是说，每次从低特权级跳转到高特权级，都等于进入了一个新的函数，拥有独立的堆栈。 由于 TSS 只需要在低特权级向高特权级跳转时找到 <code>SS0/1/2</code> 和 <code>ESP0/1/2</code> 的位置，ring3 的栈段选择子和栈指针没有静态存储在 TSS 中的必要。因此虽然 i386 有四个特权级，TSS 堆栈却只有三组存储 <code>SS</code> 和 <code>ESP</code> 的位置。</p></div></div><h3 id="中断通信" tabindex="-1"><a class="header-anchor" href="#中断通信"><span>中断通信</span></a></h3><p>中断连接起了硬件、操作系统内核和用户程序：</p>',14),s=e('<p>󱜸 如何区分不同的硬件中断和系统调用？ i386 系统采用了中断向量表（IDT）维护中断号对应的中断处理程序地址。每一个中断号，都有其指定含义，例如 <code>0x00</code> 表示 CPU 除法除零错误。按照规定，<code>0x00-0x1F</code> 这 32 个中断用于硬件中断（CPU 和 8259A 连接的外设）；<code>0x20-0xFF</code> 留给操作系统来指定。这 256 个中断，构成了硬件和用户程序与操作系统沟通的桥梁。</p><div class="callout" data-callout="tip"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-flame"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"></path></svg></div><div class="callout-title-inner">BIOS 与 IDT</div></div><div class="callout-content"><p>在 BIOS 和实模式中，我们就可以使用 <code>int</code> 软中断来打印屏幕，此时的 IDT 中其实已经写入了 BIOS 中实现的基本中断处理程序。在操作系统初始化时，实际上是覆盖 IDT 表中原有的处理函数。</p></div></div><p>一般来说，系统调用被放在了 <code>0x80</code> 的位置，而具体执行何种调用，取决于写入寄存器的传参；返回值也是通过写入和读取寄存器实现的。</p><h4 id="变与不变" tabindex="-1"><a class="header-anchor" href="#变与不变"><span>变与不变</span></a></h4><p>󱜸 跳转的过程中，哪些寄存器的值会改变？该如何传参？ i386 提供了 <code>pusha</code> 和 <code>popa</code> 指令用于将通用寄存器的值压入和弹出当前栈。在内核函数接手前，CPU 已经将<code>SS</code> 和 <code>ESP</code> 进行了修改，而其他的寄存器值保持不变。因此，我们可以利用不变的寄存器来传递系统调用的参数。 值得注意的是，用户程序可没法保证传回来的寄存器值不变（因为可能有返回值的存在）。因此，比较稳健的做法是在用户程序发起系统调用前保留寄存器的值。</p><h4 id="读与写" tabindex="-1"><a class="header-anchor" href="#读与写"><span>读与写</span></a></h4><p>读写（I/O）是一个简单但完整的硬件、操作系统内核和用户程序通过中断通信的过程。三个子系统的行为如下：</p><ul><li>硬件（键盘）：当用户按下按键的时候，通过电路发送信号，8259A 获取信号后发送中断信号（在实验中，中断号为 <code>0x21</code>）</li><li>操作系统内核： <ul><li>处理 <code>0x21</code>（键盘按键中断）：根据按键，向输入缓存区 <code>keyBuffer</code> 中写入/删除字符，并将结果输出在屏幕上。</li><li>处理 <code>0x80</code>（系统调用中断） <ul><li>读取字符：从 <code>keyBuffer</code> 中取出一个字符</li><li>读取字符串：从 <code>keyBuffer</code> 中取出字符串</li><li>打印字符/字符串：向显存中写入字符/字符串</li></ul></li></ul></li><li>用户程序：发起 <code>0x80</code> 系统调用，通过写寄存器传入参数（读/写），从寄存器中获取返回值（字符）</li></ul><p>󱜸 键盘按键和读取的调用先后顺序是怎么样的？ 在操作系统视角下，键盘按键和读取是独立的，并不存在先放入 <code>keyBuffer</code> 再从中取值的先后顺序。此时，为了保证正常的读入，需要对输入进行缓存。实验中选择实现了比较常见的缓存方式：不断将键盘输入写入缓存，换行为止。</p><ul><li><code>syscallGetChar</code> 行为与 <code>getchar()</code> 相似，如果缓存区非空，直接取第一个字符；否则会等待到按下换行，然后只取缓存区中的第一个字符返回。</li><li><code>syscallGetStr</code> 行为与 <code>scanf(&quot;%s&quot;)</code> 相似，如果缓存区非空，直接取从头开始到空格或换行结束（以 <code>\\0</code> 而空格或换行结尾）；否则会等待到按下换行，然后取缓存区从头开始到空格或换行结束。 实现中，可以使用 <code>hlt</code> 指令让 CPU 休眠直到下一次中断到来。</li></ul>',10);function r(h,p){const l=o("Mermaid");return c(),d("div",null,[n,t(l,{id:"mermaid-134",code:"eJxLy8kvT85ILCpR8Anico12DgiN5XKMfrpk2ot1+2K5nKOfT1nxrGP78xXdT3f1x3IVlyalFyUWZCg8m9z7ZO+c55t3P989/2lb67MFO7icooFani5pf7ly49OuFe/3dDxfuObJ7m1Pl7Q8n9AGMeD9ns5YLrfop+t3Pt01BVkilsslGmLYiw3NQCtR5VLzUrhcFXR1X+yf8GJhz9M9TU937NDVtVNw43IEikKsebJj7bNpa0GiTlzOIFEk00CiLlwuQNHMotQSEM+ZCwB/3oW4"}),s])}const S=i(a,[["render",r],["__file","Lab 2：从内核到用户.html.vue"]]),v=JSON.parse('{"path":"/blogs/OS/Lab%202%EF%BC%9A%E4%BB%8E%E5%86%85%E6%A0%B8%E5%88%B0%E7%94%A8%E6%88%B7.html","title":"Lab 2：从内核到用户","lang":"zh-CN","frontmatter":{"date":"2025-03-25","categories":["OS"],"prev":{"text":"Lab 1：PC，启动","link":"/blogs/OS/Lab%201%EF%BC%9APC%EF%BC%8C%E5%90%AF%E5%8A%A8.html"},"next":{"text":"Lab 3：进程调度","link":"/blogs/OS/Lab%203%EF%BC%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.html"}},"headers":[{"level":2,"title":"Lab 2：从内核到用户","slug":"lab-2-从内核到用户","link":"#lab-2-从内核到用户","children":[{"level":3,"title":"系统接手","slug":"系统接手","link":"#系统接手","children":[]},{"level":3,"title":"特权级跳转","slug":"特权级跳转","link":"#特权级跳转","children":[]},{"level":3,"title":"中断通信","slug":"中断通信","link":"#中断通信","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"filePathRelative":"blogs/OS/Lab 2：从内核到用户.md"}');export{S as comp,v as data};
