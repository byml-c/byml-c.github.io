import{_ as s,o as n,c as a,a as e}from"./app-BGj8nCRA.js";const l="/assets/image-23-BMFMIhHs.png",c={},t=e(`<h2 id="lab-3-进程调度" tabindex="-1"><a class="header-anchor" href="#lab-3-进程调度"><span>Lab 3：进程调度</span></a></h2><h3 id="进程切换" tabindex="-1"><a class="header-anchor" href="#进程切换"><span>进程切换</span></a></h3><p>在状态机视角下，进程切换的本质是状态机的切换。对于用户程序来说，进程切换是无感知的。 󱜸 一个完整的状态机具体会包含哪些元素？ 完整的状态机被存储在 PCB 块中，一个简易的 PCB 块包含了下面这些元素：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre class="language-c"><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">ProcessTable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">uint32_t</span> stack<span class="token punctuation">[</span>MAX_STACK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 程序栈</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">StackFrame</span> regs<span class="token punctuation">;</span> <span class="token comment">// 所有寄存器</span></span>
<span class="line">    <span class="token class-name">uint32_t</span> stackTop<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">uint32_t</span> prevStackTop<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> state<span class="token punctuation">;</span>     <span class="token comment">// 程序运行状态，包括 Running, Runnable, Blocked, Dead</span></span>
<span class="line">    <span class="token keyword">int</span> timeCount<span class="token punctuation">;</span> <span class="token comment">// 运行时间计数，用于调度</span></span>
<span class="line">    <span class="token keyword">int</span> sleepTime<span class="token punctuation">;</span> <span class="token comment">// 挂起时间计数，用于阻塞</span></span>
<span class="line">    <span class="token class-name">uint32_t</span> pid<span class="token punctuation">;</span>  <span class="token comment">// 进程号</span></span>
<span class="line">    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>󱜸 一个完整的进程切换流程是怎么样的？</p><ol><li>程序 1 发起中断/时钟中断，进入内核态 <ul><li>CPU 访问 TSS 表，获取 SS0 和 ESP0，赋值给对应寄存器</li><li>CPU 切换至内核态，将 <code>SS</code> 和 <code>ESP</code> 压入内核栈</li><li>CPU 将 <code>EFLAGES</code>、<code>CS</code>、<code>EIP</code> 依次加入内核态的栈</li><li>CPU 根据 IDT 跳转到中断处理程序所在地址</li></ul></li></ol><blockquote><p>此时完整的内核栈： <code>SS → ESP → EFLAGS → CS → EIP</code></p></blockquote><ol start="2"><li>进入进程调度函数 <ul><li>操作系统内核保存当前进程的更多上下文信息 <ul><li>向栈顶压入中断号和错误码</li><li><code>pushal</code>：将 CPU 寄存器压入内核态栈</li><li>依次将 <code>ds</code>、<code>es</code>、<code>fs</code>、<code>gs</code> 选择子压入内核态栈</li></ul></li></ul></li></ol><blockquote><p>此时完整的内核栈： <code>SS → ESP → EFLAGS → CS → EIP → IRQ → ERROR_CODE → CPU 寄存器 → DS → ES → FS → GS</code></p></blockquote><ol start="3"><li>进程调度 <ul><li>通过调度算法选择/更新进程状态 <ul><li>对于 <code>BLOCKED</code> 进程，更新其状态</li><li>对于 <code>RUNNING</code> 进程，判断是否应当切换进程</li></ul></li><li>切换到选定的进程 <ul><li>通过修改 <code>ESP</code>，从进程 1 的内核栈切换到进程 2 的内核栈 <ul><li>两个进程的内核栈在形式上是完全相同的</li></ul></li><li>修改 TSS 表的 SS0 和 ESP0，使得下次中断进入进程 2 的内核栈</li><li>从进程 2 的内核栈恢复上下文 <ul><li>依次弹出 <code>gs</code>、<code>fs</code>、<code>es</code>、<code>ds</code></li><li><code>popal</code>：将 CPU 寄存器赋值</li><li><code>addl $8, %esp</code>：跳过 <code>ERROR_CODE</code> 和 <code>IRQ</code> 信息</li><li><code>iret</code></li></ul></li></ul></li></ul></li></ol><blockquote><p>此时完整的内核栈： <code>SS → ESP → EFLAGS → CS → EIP</code></p></blockquote><ol start="4"><li>切换到新进程的用户态 <ul><li>CPU 依次从内核中弹出并赋值 <code>EIP</code>、<code>CS</code>、<code>EFLAGS</code>、<code>ESP</code>、<code>SS</code></li><li>CPU 切换回用户态执行进程 2 的代码</li></ul></li></ol><h3 id="进程创建" tabindex="-1"><a class="header-anchor" href="#进程创建"><span>进程创建</span></a></h3><p>󱜸 进程的初始状态是什么？ 根据进程切换的流程，在被切换时进程应处于内核态、堆栈完整的时刻。进程的初始状态正是如此：内核态栈指针指向完整的内核栈。以如下内核栈为例：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre class="language-c"><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">StackFrame</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">uint32_t</span> gs<span class="token punctuation">,</span> fs<span class="token punctuation">,</span> es<span class="token punctuation">,</span> ds<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">uint32_t</span> edi<span class="token punctuation">,</span> esi<span class="token punctuation">,</span> ebp<span class="token punctuation">,</span> xxx<span class="token punctuation">,</span> ebx<span class="token punctuation">,</span> edx<span class="token punctuation">,</span> ecx<span class="token punctuation">,</span> eax<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">uint32_t</span> irq<span class="token punctuation">,</span> error<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">uint32_t</span> eip<span class="token punctuation">,</span> cs<span class="token punctuation">,</span> eflags<span class="token punctuation">,</span> esp<span class="token punctuation">,</span> ss<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构体变量的地址实际上是栈顶地址：</p><ul><li><code>&amp;pcb[valid].regs = &amp;pcb[valid].regs.gs = 0x00108a48</code></li><li><code>&amp;pcb[valid].regs.ss = 0x00108a90</code></li></ul><figure><img src="`+l+'" alt="" title="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因此，只需将内核栈栈顶指针指向内核栈结构体的地址，即可指向完整内核栈。 󱜸 fork 系统调用应该如何实现？ fork 系统调用需要确保拷贝了程序的完整状态机，应包含寄存器和内存两部分。如果使用完整复制内存的方法，需要确保复制完成后才设置子进程状态为 <code>RUNNABLE</code>，否则在允许嵌套中断后可能出现未复制完整就开始运行的错误</p><h3 id="嵌套中断" tabindex="-1"><a class="header-anchor" href="#嵌套中断"><span>嵌套中断</span></a></h3><p>嵌套中断是在进程 1 处于内核态时，产生了新的时钟中断等其他中断的情况。此时需要考虑的是进程原来的内核态栈指针应如何处理：</p><ul><li>为了保证处理完中断后可以继续执行，原来的栈指针需要保存</li><li>为了保证新的中断能被正确处理，新的栈应当是进程切换的结构，指针也要进行相应的调整</li></ul><p>使用中间变量暂存的方法即可处理。但由于为单个 PCB 分配的 StackFrame 空间只够一次进程切换，新中断实际上存储在了 PCB 的栈空间中（自然上溢到栈空间了）。</p>',23),p=[t];function i(o,d){return n(),a("div",null,p)}const r=s(c,[["render",i],["__file","Lab 3：进程调度.html.vue"]]),k=JSON.parse('{"path":"/blogs/OS/Lab%203%EF%BC%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.html","title":"Lab 3：进程调度","lang":"zh-CN","frontmatter":{"date":"2025-04-16","categories":["OS"],"prev":{"text":"Lab 2：从内核到用户","link":"/blogs/OS/Lab%202%EF%BC%9A%E4%BB%8E%E5%86%85%E6%A0%B8%E5%88%B0%E7%94%A8%E6%88%B7.html"}},"headers":[{"level":2,"title":"Lab 3：进程调度","slug":"lab-3-进程调度","link":"#lab-3-进程调度","children":[{"level":3,"title":"进程切换","slug":"进程切换","link":"#进程切换","children":[]},{"level":3,"title":"进程创建","slug":"进程创建","link":"#进程创建","children":[]},{"level":3,"title":"嵌套中断","slug":"嵌套中断","link":"#嵌套中断","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"filePathRelative":"blogs/OS/Lab 3：进程调度.md"}');export{r as comp,k as data};
